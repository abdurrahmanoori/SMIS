# Development Guidelines

## Code Quality Standards

### Nullable Reference Types
- **Enabled project-wide** via `<Nullable>enable</Nullable>` in .csproj files
- Use `!` null-forgiving operator sparingly and only when null-safety is guaranteed
- Prefer explicit null checks over null-forgiving operators
- Use `string?` for nullable strings, `string` for non-nullable

### Implicit Usings
- **Enabled** via `<ImplicitUsings>enable</ImplicitUsings>` in all projects
- Common namespaces (System, System.Collections.Generic, System.Linq) are automatically imported
- Explicit using statements only for domain-specific namespaces

### Auto-Generated Code
- Migration files and model snapshots include `// <auto-generated />` header
- Disable warnings in auto-generated code: `#pragma warning disable 612, 618`
- Never manually edit auto-generated migration files

### Naming Conventions
- **Classes/Interfaces**: PascalCase (e.g., `UserService`, `IUserService`)
- **Methods**: PascalCase (e.g., `CreateUserAsync`, `GetByIdAsync`)
- **Properties**: PascalCase (e.g., `FirstName`, `IsActive`)
- **Private fields**: _camelCase with underscore prefix (e.g., `_userManager`, `_dataHelper`)
- **Local variables**: camelCase (e.g., `userId`, `createResult`)
- **Constants**: PascalCase or UPPER_SNAKE_CASE (e.g., `const string name = "DUPLICATE-NAME-TEST"`)
- **Test methods**: PascalCase with descriptive names (e.g., `Post_CreateValidLanguage_ReturnsOk`)

### File Organization
- One class per file
- File name matches class name exactly
- Organize using statements: System namespaces first, then third-party, then project namespaces
- Use file-scoped namespaces (C# 10+) where applicable

## Architectural Patterns

### Result Pattern
- Use `Result<T>` wrapper for all service/handler responses
- Standard factory methods:
  - `Result<T>.SuccessResult(data, message)` - Successful operation
  - `Result<T>.NotFoundResult(id)` - Entity not found
  - `Result<T>.FailureResult(description)` - Operation failed
  - `Result<T>.WithErrors(errors)` - Validation errors
- Result structure:
  ```csharp
  public class Result<T>
  {
      public T? Response { get; set; }
      public bool Success { get; set; }
      public string? Message { get; set; }
      public List<ValidationError>? Errors { get; set; }
  }
  ```

### Async/Await Pattern
- **All I/O operations are async**
- Method names end with `Async` suffix (e.g., `CreateUserAsync`, `GetByIdAsync`)
- Use `Task<T>` for async methods returning values
- Use `Task` for async methods without return values
- Always await async calls - no `.Result` or `.Wait()`
- Example:
  ```csharp
  public async Task<Result<UserDto>> GetByIdAsync(string userId)
  {
      var user = await _userManager.FindByIdAsync(userId);
      if (user == null) return Result<UserDto>.NotFoundResult(userId);
      return Result<UserDto>.SuccessResult(ToDto(user));
  }
  ```

### Dependency Injection
- Constructor injection for all dependencies
- Store dependencies in private readonly fields
- Example:
  ```csharp
  private readonly UserManager<ApplicationUser> _userManager;
  private readonly RoleManager<ApplicationRole> _roleManager;
  
  public UserService(UserManager<ApplicationUser> userManager, RoleManager<ApplicationRole> roleManager)
  {
      _userManager = userManager;
      _roleManager = roleManager;
  }
  ```

### Repository Pattern
- Generic repository interface: `IGenericRepository<T>`
- Domain-specific repository interfaces extend generic
- Implementations in Infrastructure layer
- Always use `AsNoTracking()` for read-only queries

### CQRS with MediatR
- Commands modify state (Create, Update, Delete)
- Queries read state (Get, List)
- Handlers in Application/Features/ organized by domain
- One handler per command/query

## Testing Standards

### Test Class Structure
- Inherit from `BaseIntegrationTest` for integration tests
- Use `CustomWebApplicationFactory` for test server setup
- Constructor injection for test dependencies
- Override `InitializeAsync()` for test setup
- Example:
  ```csharp
  public class LanguageIntegrationTests : BaseIntegrationTest
  {
      private readonly LanguageTestDataHelper _dataHelper;
      
      public LanguageIntegrationTests(CustomWebApplicationFactory factory, ITestOutputHelper output)
          : base(factory, output)
      {
          _dataHelper = new LanguageTestDataHelper(Client);
      }
      
      public override async Task InitializeAsync()
      {
          await _dataHelper.GetOrCreateDependencies();
      }
  }
  ```

### Test Naming Convention
- Format: `MethodName_Scenario_ExpectedResult`
- Examples:
  - `Post_CreateValidLanguage_ReturnsOk`
  - `Get_LanguageById_NonExisting_ReturnsNotFound`
  - `Put_UpdateExistingLanguage_ReturnsUpdatedLanguage`
  - `Delete_NonExistingLanguage_ReturnsNotFound`

### Test Assertions
- Use FluentAssertions for readable assertions
- Common patterns:
  ```csharp
  response.StatusCode.Should().Be(HttpStatusCode.OK);
  created.Should().NotBeNull();
  created!.Name.Should().Be(expected.Name);
  paged.Items.Count.Should().BeGreaterOrEqualTo(0);
  updated!.IsActive.Should().BeFalse();
  ```

### Test Data Builders
- Use builder pattern for test data creation
- Fluent API with method chaining
- Example:
  ```csharp
  var dto = _dataHelper.CreateLanguageBuilder()
      .WithName("English")
      .WithCode("en")
      .WithIsActive(true)
      .Build();
  ```

### Test Helpers
- Extract common test operations into helper methods
- Centralize API endpoint definitions in `ApiEndpoints` class
- Use `LogIfError()` for debugging failed tests
- Example:
  ```csharp
  private async Task<LanguageDto> CreateLanguageAsync(LanguageCreateDto dto, string testName)
  {
      var response = await Client.PostAsJsonAsync(ApiEndpoints.Language, dto);
      await LogIfError(response, testName);
      response.EnsureSuccessStatusCode();
      return (await response.Content.ReadFromJsonAsync<LanguageDto>())!;
  }
  ```

### Test Cleanup
- Use `TestCleanupExtensions` for cleanup operations
- Delete created entities after tests when necessary
- Example:
  ```csharp
  var deleteResponse = await Client.DeleteAsync($"{ApiEndpoints.Language}/{created.Id}");
  deleteResponse.EnsureSuccessStatusCode();
  ```

## Entity Framework Core Patterns

### Entity Configuration
- Use Fluent API in separate configuration classes
- Configuration classes in Infrastructure/EntityConfigurations/
- Apply configurations in `OnModelCreating`:
  ```csharp
  modelBuilder.Entity<Category>(b =>
  {
      b.Property(e => e.Name).IsRequired().HasMaxLength(200);
      b.Property(e => e.Code).HasMaxLength(50);
      b.HasIndex(e => e.Code);
  });
  ```

### Relationships
- Explicit foreign key properties
- Navigation properties for related entities
- Configure delete behavior explicitly:
  - `DeleteBehavior.Cascade` - Delete related entities
  - `DeleteBehavior.Restrict` - Prevent deletion if related entities exist
  - `DeleteBehavior.SetNull` - Set foreign key to null

### Indexes
- Create indexes for frequently queried columns
- Unique indexes for unique constraints
- Composite indexes for multi-column queries
- Example:
  ```csharp
  b.HasIndex("TranslationKeyId", "LanguageNo").IsUnique();
  b.HasIndex("CreatedAt");
  b.HasIndex("Level");
  ```

### Data Seeding
- Use `HasData()` for initial seed data
- Seed data in entity configurations or separate seeder classes
- Always provide IDs for seeded entities
- Example:
  ```csharp
  b.HasData(
      new Category
      {
          Id = "1",
          Code = "BEV",
          Name = "Beverages",
          IsActive = true,
          CreatedDate = DateTime.Now
      }
  );
  ```

### Interceptors
- `AuditInterceptor` - Automatically populate audit fields (CreatedBy, UpdatedBy, CreatedDate, UpdatedDate)
- `EntityPKInterceptor` - Generate primary keys for new entities
- Register interceptors in DbContext configuration

## Middleware Patterns

### Request/Response Logging
- Skip logging for specific paths (swagger, health checks)
- Capture request and response bodies
- Store in HttpContext.Items for access in other middleware
- Enable request buffering for body reading
- Example:
  ```csharp
  if (_skipPaths.Any(path => context.Request.Path.StartsWithSegments(path)))
  {
      await _next(context);
      return;
  }
  
  request.EnableBuffering();
  request.Body.Position = 0;
  var body = await new StreamReader(request.Body).ReadToEndAsync();
  request.Body.Position = 0;
  ```

### Stream Management
- Always restore original response stream
- Use `using` statements for disposable streams
- Copy captured response back to original stream
- Example:
  ```csharp
  var originalResponseBodyStream = context.Response.Body;
  using var responseBodyStream = new MemoryStream();
  context.Response.Body = responseBodyStream;
  
  try
  {
      await _next(context);
      await responseBodyStream.CopyToAsync(originalResponseBodyStream);
  }
  finally
  {
      context.Response.Body = originalResponseBodyStream;
  }
  ```

## Identity & Security Patterns

### User Management
- Use ASP.NET Core Identity UserManager and RoleManager
- Always check operation results (IdentityResult.Succeeded)
- Convert IdentityErrors to ValidationErrors
- Example:
  ```csharp
  var createResult = await _userManager.CreateAsync(user, input.Password);
  if (!createResult.Succeeded)
  {
      return Result<string>.WithErrors(createResult.Errors.Select(e => new ValidationError
      {
          Code = e.Code,
          Description = e.Description
      }).ToList());
  }
  ```

### Role Management
- Check if role exists before creating
- Use `Distinct()` to avoid duplicate role assignments
- Handle role creation errors gracefully
- Example:
  ```csharp
  foreach (var role in input.Roles.Distinct())
  {
      if (!await _roleManager.RoleExistsAsync(role))
      {
          await _roleManager.CreateAsync(new ApplicationRole { Name = role });
      }
  }
  ```

### Password Management
- Use UserManager.ChangePasswordAsync for password changes
- Require current password for verification
- Return validation errors on failure

## API Response Patterns

### HTTP Status Codes
- `200 OK` - Successful operation
- `201 Created` - Resource created (optional, often use 200)
- `400 Bad Request` - Validation errors
- `404 Not Found` - Resource not found
- `409 Conflict` - Duplicate resource
- `500 Internal Server Error` - Unhandled exceptions

### Pagination
- Use `PagedList<T>` for list endpoints
- Query parameters: `pageNumber`, `pageSize`
- Response includes: Items, PageNumber, PageSize, TotalCount, TotalPages
- Example:
  ```csharp
  var response = await Client.GetAsync($"{ApiEndpoints.Language}?pageNumber=1&pageSize=10");
  var paged = await response.Content.ReadFromJsonAsync<PagedList<LanguageDto>>();
  ```

### Error Handling
- Global exception middleware catches unhandled exceptions
- Return structured error responses with ValidationError list
- Include error codes and descriptions
- Log errors with context information

## Common Code Idioms

### Null Checking
```csharp
if (user == null) return Result<UserDto>.NotFoundResult(userId);
if (string.IsNullOrWhiteSpace(input.Email)) user.Email = input.Email;
```

### Collection Operations
```csharp
var toRemove = currentRoles.Except(input.Roles).ToArray();
var toAdd = input.Roles.Except(currentRoles).ToArray();
foreach (var role in input.Roles.Distinct()) { }
```

### Conditional Updates
```csharp
if (!string.IsNullOrWhiteSpace(input.Email)) user.Email = input.Email;
if (input.EmailConfirmed.HasValue) user.EmailConfirmed = input.EmailConfirmed.Value;
```

### DTO Mapping
```csharp
private static UserDto ToDto(ApplicationUser user)
{
    return new UserDto
    {
        Id = user.Id,
        UserName = user.UserName,
        Email = user.Email,
        // ... other properties
    };
}
```

### LINQ Queries
```csharp
var users = await _userManager.Users.AsNoTracking().ToListAsync();
var dtos = users.Select(ToDto).ToList();
```

## Validation Patterns

### FluentValidation
- Create validator classes for DTOs
- Register validators in DI container
- Validation runs automatically in MediatR pipeline
- Return 400 Bad Request with validation errors

### Domain Validation
- Validate in domain entities for business rules
- Throw `DomainValidationException` for domain rule violations
- Use value objects (Email, PhoneNumber, TaxNumber) for validated types

### Input Validation
- Check for null/empty strings
- Validate required fields
- Validate string lengths (MaxLength attributes)
- Validate data types and formats

## Logging Standards

### Structured Logging with Serilog
- Use structured logging properties
- Log levels: Debug, Information, Warning, Error, Fatal
- Include context information (UserId, RequestId, etc.)
- Log to multiple sinks (Console, Seq, Database)

### Log Enrichment
- Use `LogEnrichmentMiddleware` to add context
- Include user information, request path, correlation IDs
- Store in HttpContext.Items for access throughout request

### Performance Profiling
- Use MiniProfiler for performance analysis
- Profile database queries automatically
- Access results at `/profiler/results-index`

## Best Practices Summary

1. **Always use async/await** for I/O operations
2. **Use Result<T> pattern** for consistent error handling
3. **Follow naming conventions** strictly
4. **Write descriptive test names** following the pattern
5. **Use FluentAssertions** for readable test assertions
6. **Enable nullable reference types** and handle nulls explicitly
7. **Use dependency injection** for all dependencies
8. **Separate concerns** following Clean Architecture
9. **Use EF Core interceptors** for cross-cutting concerns
10. **Log structured data** with Serilog
11. **Validate input** at multiple layers (DTO, Domain, Database)
12. **Use builder pattern** for test data creation
13. **Clean up test data** when necessary
14. **Handle errors gracefully** with proper status codes
15. **Document APIs** with Swagger/OpenAPI
